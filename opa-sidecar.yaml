apiVersion: apps/v1
kind: Deployment
metadata:
  name: not-important
spec:
  template:
    spec:
      containers:
        - name: opa
          # There is really no need to ever run OPA as root, so the rootless
          # container should be considered the default. Do note however that
          # the default container is very slim - if you need to exec into the
          # container or run normal UNIX tools for debugging, use the `-debug`
          # suffix instead.
          image: docker.io/openpolicyagent/opa:opa:0.24.0-rootless
          # Purely informational - we expose port 8181 for the OPA REST API,
          # and 8282 for diagnostics (/health and /metrics). This separation
          # allows us to expose the diagnostics endpoints without allowing
          # external access to other OPA endpoints.
          ports:
            - 8181
            - 8282
          # Start the OPA server with minimal configuration.
          args: [
            "run",
            "--server",
            # If sourcing policies or data from the file system, ignore
            # any hidden files as these are most likely not meant to be
            # read by OPA.
            "--ignore=.*",
            # Bind OPA only to localhost to ensure we avoid unecessary
            # exposure of the OPA API outside of the pod. We can still
            # reach the diagnostic endpoints from the config option below.
            "--addr=localhost:8181",
            # Expose /health and /metrics endpoints on a separate port,
            # allowing tools like Prometheus to scrape them without having
            # access to other OPA endpoints.
            "--diagnostic-addr=:8282",
            # Logging at info level is essentially enabling access logging.
            # While occasionally useful the decision log feature already offers
            # a much richer logging system, and since info level is chatty it
            # will likely make it more difficult to spot real problems and
            # errors right away.
            # NOTE: If running with "--set=decision_logs.console=true" then
            # --log-level MUST be set to info at minimum or else decision logs
            # won't be printed to the console. See ticket
            # https://github.com/open-policy-agent/opa/issues/2733 for tracking.
            "--log-level=error",
            # Number of seconds to wait for graceful shutdonw before terminating
            # forcefully (default 10 seconds). Set somewhere close to the
            # terminationGracePeriodSeconds value configured for the pod (which
            # by default is 30 seconds).
            "--shutdown-grace-period=25"
          ]
          # Configure liveness and readiness probes. If downloading a large
          # dataset as part of the bundle you may want to adjust the value of
          # initialDelaySeconds accordingly. The default value of timeoutSeconds
          # of 1 may also be increased somewhat - for any other settings the
          # defaults are usually fine.
          livenessProbe:
            httpGet:
              path: /health
              port: 8282
              scheme: HTTP
            initialDelaySeconds: 15
            timeoutSeconds: 5
          readinessProbe:
            httpGet:
              # Make sure to include bundle loading as part of accepted
              # readiness condition
              path: /health?bundle=true
              port: 8282
              scheme: HTTP
            initialDelaySeconds: 15
            timeoutSeconds: 5
          # These values will obviously differ in most setups, but these
          # provide a good baseline. When allocating resources for OPA
          # one should take the following into account:
          # * Memory - OPA itself requires something like 10-20Mi - the rest
          # depends entirely on how much data OPA needs to keep in memory
          # for it's internal in-memory data source (anything you can import
          # in your policy like import data.xxx.yyy). A good rule of thumb is
          # to check the size of the data serialized to JSON and multiply that
          # by 20 to get an approximation of how much memory to allocate.
          # * CPU - these numbers depends on so many factors, like hardware used,
          # number of OPA instances, complexity of policy, and so on, that the
          # only honest answer is "test and measure". The numbers below however
          # probably a good starting point for that.
          resources:
            requests:
              memory: "64Mi"
              cpu: "125m"
            limits:
              memory: "256Mi"
              cpu: "700m"
          # Optionally, use the kubernetes downward API to inject properties
          # from the pod or container environment. The values for these can then
          # be retrieved and used from inside rego policies using
          # opa.runtim().env["ENV_VAR_NAME"]
          variables:
            - name: APP_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.labels['app']
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          # OPA (when run with the -rootless image tag) does not require any
          # special privileges and does not write data to disk. We can thus
          # apply the most strict securityContext available.
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 12000
            runAsGroup: 12000
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - all
